# Bild-an-Eletronic-Speed-Controller-
This project aims to outline an ESC (Electronic Speed Controller) using KiCad, simulate its behavior with LTspice, and study its electronic fundamentals. Based on this, a PCB will be designed and an ESP32 will be used for control purposes.

## 1 Materials
- Controller: ESP32-S3
- 6 Mosfets 
- Drive Gate
- resistor pull-down 
- 2 capcitor bypass
- 1 capacitor bootstrap 
- 1 Diodo Bootstrap

## 2 theoretical fundamentals
### 2.1 ESP32-S3
Responsible for the commutation logic, BEMF (Back Electromotive Force) reading, and PWM generation.<br>
First, we will start with PWM. On ESP32, we can use a module called MCPWM (MOTOR CONROL PULSE WIDTH MODULATION).This module focuses on controlling three-phases motor like BLDCs, and offers high frequency occuracy.
Moreover, The ESP32 outputs a 3.3 V PWM signal 

*according to Espressif's official documatation:* 

> "ESP32-S3 integrates two MCPWMs that can be used to drive digital motors and smart light. Each MCPWM
peripheral has one clock divider (prescaler), three PWM timers, three PWM operators, and a capture module.
PWM timers are used for generating timing references. The PWM operators generate desired waveform based
on the timing references. Any PWM operator can be configured to use the timing references of any PWM
timers. Different PWM operators can use the same PWM timer’s timing references to produce related PWM
signals. PWM operators can also use different PWM timers’ values to produce the PWM signals that work
alone. Different PWM timers can also be synchronized together."
> — *Espressif Documentation, ESP32-S3 MCPWM*

[reference](https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/api-reference/peripherals/mcpwm.html](https://www.espressif.com/sites/default/files/documentation/esp32-s3_datasheet_en.pdf)

**Pin Assignment**<br>
For MCPWM, the pins used can be chosen from any GPIOs via the GPIO Matrix.<br>

**Advantages**<br>
- High-resolution PWM
- Simultaneous PWM
- Supports Dead-Time insertion

### 2.2 Drive Gate

First, The gate driver amplifies the control signal sent by the ESP32 to the motor's power stage, typically increasing the voltage from 3.3V to 10-12V. This is necessary to properly switch the MOSFETs used in the motor drive. Futhermore, it enable fast commutttion between high-side and low-side MOSFETs, and also allows the bootstrap circuitry for driving high-side MOSFETs.<br>

Some gate drivers also support dead-time insertion, which helps prevent both the high-side and low-side transistors from being on at the same time — a condition that would result in a short circuit. Finally, the gate driver helps to isolate the microcontroller from electrical noise generated by Back-EMF and fast switching transients, improving overall system reliability.

> **Selected driver:IRS2003S **  
| IRS2003S   |
|------------|
| Dead-Time  |

[reference](https://www.alldatasheet.com/datasheet-pdf/view/1238238/INFINEON/IRS2003S.html)

### 2.3 Mosfets 

| Model         | V<sub>DSS</sub> | I<sub>D</sub> | R<sub>DS(on)</sub> | V<sub>GS(th)</sub>  | comment                                                    |
| ------------- | --------------  | ------------- | ------------------ | ------------------ | ----------------------------------------------------------- |
| **IRF3205**   | 55 V            | 110 A         | \~8 mΩ             | 2–4 V              | mainstream. Requires a good cooler                          |

[Datasheet](https://www.alldatasheet.com/datasheet-pdf/view/68131/IRF/IRF3205.html)

For this project, The IRF3205 was chosen owing to its affordability and compatibility with the required gate drive Voltage (Vgs). Furthermore, 6 MOSFETs are needed to bild a three-phase half-bridge: three will operate in high side and three on the low side. 

## 3 METHODS

### 3.1 Bootstrap circuit 

When the Low Side Input is high, the gate driver sends a high signal through the Low Side Output pin to the gate of the low-side MOSFET. As a result, the current path starts from the VCC source, flows through the bootstrap diode, and charges the bootstrap capacitor. Then, the current flows from the drain to the source of the low-side transistor. Since the source is connected to ground, the motor's voltage also drops to ground.

<p align="center">
<img width="509" height="326" alt="image" src="https://github.com/user-attachments/assets/2e1902e8-834b-4009-ad38-e9e5699913b8" />
</p>

On the other hand, when the High Side Input of the gate driver is high, the High Side Output pin activates the gate of the high-side MOSFET with the help of the bootstrap capacitor. As a result, current flows from the drain to the source of the high-side transistor, delivering a high voltage to the motor.

<p align="center">
<img width="555" height="267" alt="image" src="https://github.com/user-attachments/assets/bd22d915-a22c-4d1d-9f75-3b7442481012" />
</p>

### 3.2 calculus

### 3.3 Skecht

In this project, we used KiCad software to design the circuit and better understand its logic and the types of electronic components involved.

<p align="center">
<img width="962" height="686" alt="image" src="https://github.com/user-attachments/assets/bafde194-ea83-4acc-aea8-acb5abbe2144" />
</p>

### 3.x Code's logic 

For generation of PWM signal, use main function:

```C++
void app_main(void)
{
    // Associa o GPIO ao canal MCPWM
    mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM0A, PWM_GPIO);

    // Estrutura de configuração do PWM
    mcpwm_config_t pwm_config = {
        .frequency = 1000,        // Frequência do PWM (1 kHz)
        .cmpr_a = 50.0,           // Duty cycle do canal A (50%)
        .cmpr_b = 0.0,            // Canal B não será usado
        .counter_mode = MCPWM_UP_COUNTER,
        .duty_mode = MCPWM_DUTY_MODE_0, // PWM ativo em nível alto
    };

    // Inicializa o MCPWM com as configurações acima
    mcpwm_init(MCPWM_UNIT_0, MCPWM_TIMER_0, &pwm_config);
}
```

| Function                         | What it does                                          |
| -------------------------------- | ----------------------------------------------------- |
| `mcpwm_init()`                   | Inicia o sinal PWM com uma configuração definida      |
| `mcpwm_gpio_init()`              | Liga um GPIO ao canal MCPWM A ou B                    |
| `mcpwm_set_duty()`               | Altera o duty cycle (em %) durante execução           |
| `mcpwm_start()` / `mcpwm_stop()` | Liga ou desliga o sinal (opcional)                    |


Duty cycle is the proportion of time that a PWM signal stays high during one complete cycle.

Example:
Frequência: 1kHz (1 ciclo dura 1ms)
 - Duty cycle: 50% → sinal fica 0,5 ms ligado e 0,5 ms desligado
 - Duty cycle: 75% → sinal fica 0,75 ms ligado e 0,25 ms desligado

Each module in ESP32 has 3 timers. And each timer can control the output of two PWM's signal (A and B). So inside the `void app_main`, we call `mcpwm_gpio_init` 6 times, using the parameters releted to the unit we are working with, in this case, MCPWM_UNIT_0, the timer is are use, and its speciffic channel. Finnaly, we  put the pin that are connected in ESP32.

- Timer 0 → Channel A = High phase 1, Channel B = Low phase 1

- Timer 1 → Channel A = High phase 2, Channel B = Low phase 2

- Timer 2 → Channel A = High phase 3, Channel B = Low phase 3

``` C
    // Mapeia GPIOs para MCPWM Unit 0, Timer 0, canais A e B
    mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM0A, f_PWM_GPIO_HIGH);
    mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM0B, f_PWM_GPIO_LOW);

    mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM1A, s_PWM_GPIO_HIGH);
    mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM1B, s_PWM_GPIO_LOW);

    mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM2A, t_PWM_GPIO_HIGH);
    mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM2B, t_PWM_GPIO_LOW);
```

After setting the `mcpwm_config_t cfg` structure, as described earlier, and map where the pins to their specific modele and timer, we have to initialize this setting with the `mcpwm_init` function:

``` C
    mcpwm_init(MCPWM_UNIT_0, MCPWM_TIMER_0, &cfg);
    mcpwm_init(MCPWM_UNIT_0, MCPWM_TIMER_1, &cfg);
    mcpwm_init(MCPWM_UNIT_0, MCPWM_TIMER_2, &cfg);
```

- We use `&` before `cfg` because we are passing the memory address of the variable `cfg`. In other words, we are sending a pointer to the function, not a copy of the variable. The advantage is that this is faster, and it is already the expected way to pass structures in this case.

Next, we have to sincronize the signal in a way that if one are high, other have to be low

``` C
    // HIN e LIN são complementares (mesmo duty, fases opostas).
    mcpwm_set_duty_type(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_B, MCPWM_DUTY_MODE_1);
    mcpwm_set_duty_type(MCPWM_UNIT_0, MCPWM_TIMER_1, MCPWM_OPR_B, MCPWM_DUTY_MODE_1);
    mcpwm_set_duty_type(MCPWM_UNIT_0, MCPWM_TIMER_2, MCPWM_OPR_B, MCPWM_DUTY_MODE_1);
```

The `MCPWM` model has to operator in each timer
- `MCPWM_OPR_A` → control the output A (for example, MCPWM0A, MCPWM1A, etc.)
- `MCPWM_OPR_B` → control the output B (for example, MCPWM0B, MCPWM1B, etc.)

The `MCPWM_DUTY_MODE` defines which logic level represents the “active” part of the duty cycle.
- `MCPWM_DUTY_MODE_0` → Duty activates in high level (default)
- `MCPWM_DUTY_MODE_1` → Duty activates in low level<br>
So what our code are saying is that we are controlling the output B, and defining the time of duty the output will be low, and in the rest time will be high  

Now, for securance, we can add Dead-Time 

``` C
    mcpwm_deadtime_enable(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_ACTIVE_HIGH_COMPLIMENT_MODE, 100, 100);
    mcpwm_deadtime_enable(MCPWM_UNIT_0, MCPWM_TIMER_1, MCPWM_ACTIVE_HIGH_COMPLIMENT_MODE, 100, 100);
    mcpwm_deadtime_enable(MCPWM_UNIT_0, MCPWM_TIMER_2, MCPWM_ACTIVE_HIGH_COMPLIMENT_MODE, 100, 100);
```

- In `mcpwm_deadtime_enable` the parameter `MCPWM_ACTIVE_HIGH_COMPLIMENT_MODE` means that the logic level are on when the signal are high (ACTIVE_HIGH). The COMPLIMENT means that if one are high other have to be low.
- for both last parameters, 100 ns means the time of delay to start do increase and decrease the signal: rising edge delay & falling edge delay.

### Comutation Code 

In the preveous topic, we have a great undertanding the logic of initialization, but now we have give a step on making the trapeizoidal comutation. 

| phase A  | phase B | phase C |
| -------- | ------- | --------|
|    HI    |   LO    |     F   |
|    HI    |   F     |    LO   |
|    F     |   HI    |    LO   |
|    LO    |   HI    |     F   |
|    LO    |   F     |    HI   |
|    F     |   LO    |    HI   |

- Where Hi is High, LO is low, and F is float ( without energy)

The line `const mcpwm_action_t commutation_steps[6][6]` declares an matrix `constant`, i.e the values can not change when the program are executig, for store the commutation's steps of BLDC motor<br>
- `mcpwm_action_t` it's a matrix, and a type of enumeration `enum` defined in the framework ESP-IDF. It's used for represantation an output's state of periferic MCPWM, the possible values are:
    - MCPWM_GEN_FORCED_HIGH: force a HIGH state for output
    - MCPWM_GEN_FORCED_LOW: force a LOW state for output
    - MCPWM_GEN_OFF: force a high impedance state for output (float)
- `commutation step` is the matrix's name

Each {} represents a state: {A+ A- B+ B- C+ C-}. So we have 6 states in diffets mements.

|    A+    |    A-   |   B+    |    B-  |   C+   |   C-  |
| -------- | ------- | --------| -------| ------ | ----- |
|    HI    |   LO    |     F   |    HI  |   F    |  LO   | 
|    HI    |   LO    |     F   |    LO  |   F    |  HI   |
|    F     |   LO    |    HI   |    LO  |  HI    |   
|    LO    |   HI    |     F   |
|    LO    |   F     |    HI   |
|    F     |   LO    |    HI   |



